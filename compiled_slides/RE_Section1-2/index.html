<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Reverse Engineering</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="intro-static-analysis">Intro Static Analysis</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand and utilize, at a basic level, principles relating to static analysis</li><li>Utilize, at a basic level, IDA Pro for the purpose of static analysis</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="static-analysis-tools">Static Analysis Tools</h1><ul><li><dl><dt>Strings - A very useful tool for dumping things that *look* like printable ASCII or Unicode strings</dt><dd><ul><li>For Windows: Ships with Sysinternals</li><li>Linux/Unix: Typically a strings application exists</li></ul></dd></dl></li><li>Hex Editors - Sometimes useful</li><li><dl><dt>Executable file explorers - CFF Explorer, dumpbin, objdump, otool, etc</dt><dd><ul><li>Lots of detail about sections and layout of a binary</li><li>Will discuss in greater detail in later sections</li></ul></dd></dl></li><li><dl><dt>Disassemblers - IDA Pro, radare2, etc.</dt><dd><ul><li>IDA will be our focus for the course</li><li>It is an extremely powerful tool, provides lots of useful features for annotating and investigating various binary formats</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="intro-to-ida-pro">Intro to IDA Pro</h1></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="starting-up">Starting Up</h1><ul><li>IDA Allows you to save and load work between sessions via database files</li><li>Annotations and other items can be stored and distributed this way</li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="basic-areas">Basic Areas</h1><ul><li>Functions Window</li><li>Overview Navigator</li><li>Graph Overview</li><li>Views section</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="functions-window">Functions Window</h1><ul><li>IDA will load blocks of code that resemble functions here</li><li><dl><dt>Many of them will initially be named "sub_*"</dt><dd><ul><li>Can be renamed later, as functionality is uncovered</li><li>A subset may have specific names on load, from symbols, functionality, etc</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="ida-view-and-hex-view">IDA View and Hex View</h1><ul><li>Provides a disassembly view of a section of code</li><li>Can toggle between viewing the disassembly via text view and graph view</li><li><dl><dt>Hex view gives a view in hex bytes, or other formats</dt><dd><ul><li>Selecting a block of opcodes highlights the whole instruction (if in hex)</li><li>Can synchronize selections with IDA View</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="structures-and-enums">Structures and Enums</h1><ul><li>Sections let you define structures and enum values</li><li><dl><dt>Some structure definitions may be populated via type libs and symbols</dt><dd><ul><li>Many Windows functions and parameters, for example, may be annotated in this fashion</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="imports-and-exports">Imports and Exports</h1><ul><li>Imports indicate libraries and external functions a binary relies on</li><li><dl><dt>Exports denote exported symbols</dt><dd><ul><li>May identify methods exported for use by other modules</li><li>Various other entry points, such as the CRT entry point or TLS callbacks, may appear here</li></ul></dd></dl></li><li>This topic will be covered in greater depth when discussing executable file formats</li></ul></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="useful-features">Useful Features</h1><ul><li>XREFS</li><li><dl><dt>Annotations</dt><dd><ul><li>Comments</li><li>Renaming</li></ul></dd></dl></li><li>Mapping Structure Definitions</li><li>Jump to location</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="xrefs">XREFS</h1><ul><li>Hotkey: x (from IDA View)</li><li>Gives a list of references to an item from the binary</li><li>Double-clicking entries in the list will jump to that location</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="renaming">Renaming</h1><ul><li>Hotkey: n (from IDA View)</li><li><dl><dt>Allows symbols to be renamed as functionality is discovered</dt><dd><ul><li>Makes it easy to refer back to blocks of code</li><li>Functions (in the Functions Window) can also be renamed via right-click and edit (or Ctrl+E)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="comments">Comments</h1><ul><li><dl><dt>Hotkey: ; or</dt>(from IDA View)<dd><ul><li>; - Repeatable comments</li><li>: - Single comment</li></ul></dd></dl></li><li>Repeatable comments will appear at each occurrence of the symbol</li><li>Single comments will only appear where designated</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="structure-definitions">Structure Definitions</h1><ul><li>Hotkey: t (from IDA View)</li><li>Maps a structure definitions (from the Structures tab) to a particular location in memory</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="jump-to-location">Jump to Location</h1><ul><li>Hotkey: enter (from IDA View)</li><li><dl><dt>Jumps the focus of the IDA View window to the definition of the symbol</dt><dd><ul><li>This includes functions and jump targets</li><li>Uninitialized data from other sections in the file (such as .data or .bss) can be viewed in this fashion</li><li>As can global constants, such as strings</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="other-useful-things">Other Useful Things</h1><ul><li>Clicking a symbol or register highlights its use</li><li>Can edit opcodes via hex view</li><li>Can generate a graph of uses for a particular symbol</li><li>Same principles discussed in previous section applies in terms of identifying user-defined entry point</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="labs-1a-1b">Labs 1a &amp; 1b</h1><p>From Assembly to C</p></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="binary-analysis">Binary Analysis</h1></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="id1">Objectives</h1><ul><li>Discuss and Understand, at a basic level, some strategies for approaching RE</li><li>Understand, at a basic level, some ways of identifying and applying structure to data</li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="looking-for-clues">Looking for Clues</h1><ul><li>Imports</li><li>Exports</li><li>Strings</li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="applying-structure-to-data">Applying Structure to Data</h1><ul><li>Locate data structures in disassembly</li><li>Identify structures, arrays, and constituent data members</li></ul></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="structure-identification">Structure Identification</h1><img src="./img/yep_its_wood.jpg"></img></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="structures">Structures</h1><ul><li><dl><dt>Telltale signs include:</dt><dd><ul><li>Grabbing a pointer parameter or local variable</li><li>Accessing offsets into that variable</li><li>Pointer additions/subtractions into a buffer</li></ul></dd></dl></li></ul><pre class="highlight code nasm"><span class="c1">; Copying a param</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="c1">; Loading a value 12 bytes into the buffer</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0xC</span><span class="p">]</span></pre></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="more-structure-examples">More Structure Examples</h1><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">]</span>
<span class="nf">lea</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span>
<span class="nf">push</span> <span class="nb">edx</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">call</span> <span class="nv">_strcpy</span>
<span class="nf">add</span> <span class="nb">esp</span><span class="p">,</span> <span class="mh">0x08</span></pre><pre class="highlight code c"><span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
        <span class="n">DWORD</span>   <span class="n">firstField</span><span class="p">;</span>
        <span class="n">DWORD</span>   <span class="n">secondField</span><span class="p">;</span>
        <span class="kt">char</span>    <span class="n">buf</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="arrays">Arrays</h1><ul><li><dl><dt>Same-sized accesses into a buffer might indicate an array</dt><dd><ul><li>All accesses into the buffer only read or write same sized values</li><li>Most structures have some variance in data size</li></ul></dd></dl></li><li><dl><dt>Other clues might include</dt><dd><ul><li>Accesses to sequential offsets in a loop</li><li>Use of string instructions (e.g., "rep movs*" or "rep scas*", etc.)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="structures-and-arrays">Structures and Arrays</h1><ul><li><dl><dt>Look at how fields are used in other parts of the program</dt><dd><ul><li>OS-provided function calls with known input params</li><li>Other typelib provided function definitions (e.g., static libs)</li><li>Make use of xrefs (where possible)</li></ul></dd></dl></li><li>Annotations are very useful in getting a good feel for control flow</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="structures-and-arrays-cont-d">Structures and Arrays - Cont'd</h1><ul><li>Applying dynamic analysis can also be useful</li><li><dl><dt>Hardware breakpoints may be especially helpful</dt><dd><ul><li>If point of allocation can be found, break on read/write can identify what gets copied into the buffer</li><li>Various memory printing options (Windbg/gdb) with offsets can also assist with this</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="finding-allocations">Finding Allocations</h1><p>Heap Allocations</p><ul><li><dl><dt>Look for calls to heap allocation methods</dt><dd><ul><li>malloc/calloc/etc</li><li>HeapAlloc</li><li>VirtualAlloc</li></ul></dd></dl></li><li>Example:</li></ul><pre class="highlight code nasm"><span class="nf">push</span> <span class="mh">0x30</span>
<span class="nf">call</span> <span class="nv">_malloc</span>
<span class="nf">mov</span> <span class="kt">dword</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">],</span> <span class="nb">ecx</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="id2">Finding Allocations</h1><p>Stack Allocations</p><pre class="highlight code nasm"><span class="nf">sub</span> <span class="nb">esp</span><span class="p">,</span> <span class="mh">0x30</span></pre></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="lab-2">Lab 2</h1><p>Crackme Part 2</p><h1 id="labs-2a-2b">Labs 2a &amp; 2b</h1><p>From Assembly to C</p></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>