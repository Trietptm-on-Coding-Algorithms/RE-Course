<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Reverse Engineering</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="compilers-an-introduction">Compilers - an Introduction</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand fundamental concepts pertaining to how the compilation process works</li><li>Understand and identify security mechanisms implemented by compilers</li><li>Understand and identify some features and minor optimizations performed by compilers</li><li>Understand and identify intrinsic methods</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="the-compilation-process">The Compilation Process</h1><ul><li>How do we get from a text file to a binary?</li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="lexing-the-first-step">Lexing: The First Step</h1><ul><li>Text is broken into tokens</li><li>The "how" is based on language contraints  (e.g., whitespace, semicolons, etc)</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="parsing">Parsing</h1><ul><li>The next step in interpreting text</li><li>Stream of tokens created from lexing are examined here</li><li>Abstract Syntax Tree (AST) gets built from this</li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="where-to-go-from-here">Where to go from here?</h1><ul><li><dl><dt>Several transformations typically applied</dt><dd><ul><li>the original AST gets changed a bit, losing context</li><li>Sometimes something that resembles a pseudo-assembly gets produced here (e.g., llvm ir)</li><li>Typically still has more "intent" (e.g., what the programmer intended to do) encoded than raw assembly/opcodes</li></ul></dd></dl></li><li>Optimizations get added here</li><li>Register spills and variable lifecycle gets analyzed/calculated at this point</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="and-out-comes-a-binary">... And out comes a binary?</h1><ul><li>Various sections get generated (more on this topic later)</li><li>Compilation finishes, assembly gets produced, and assembling happens</li><li>Object files get created</li><li>Linking occurs</li></ul><p>And finally....</p><ul><li>A binary gets created!</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="compiler-features">Compiler Features</h1><ul><li>A number of security features exist (and are now usually implemented by default) for compilers</li><li>Some are specific to vendors/file formats</li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="stack-canary">Stack Canary</h1><ul><li>A "cookie" that is added to the stack inside of a function call to indicate that the stack has been corrupted</li><li>Generally set at function prologue (on stack)</li><li>Typically checked just prior to function return</li></ul></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="id1">Stack Canary</h1><img src="./img/stackcookie.png"></img></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="relocations">Relocations</h1><ul><li>PE-specific</li><li>Provide information to fix up addresses on load (more on this topic later)</li><li>Makes PE files (which are not position-independent) work with ASLR</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="patch-points">Patch Points</h1><ul><li>Microsoft originated</li><li>GCC extension - ms_hook_prologue - will provide</li><li>Implementation that allows for hotpatching</li><li>Provides a 2-bytes, idempotent function prelude that can overwritten with a jmp</li><li>Typically preceded by a 5 byte (in x86, anyhow), writable area to add a bigger jmp</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="patch-point">Patch Point</h1><pre class="highlight code nasm"><span class="c1">; patchable area... 5 bytes of space</span>
<span class="nl">winfunc:</span>
        <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span> <span class="c1">; two byte reserved patch point</span></pre><p>After patch:</p><pre class="highlight code nasm"><span class="nl">patched:</span>
        <span class="nf">jmp</span> <span class="nv">newloc</span>      <span class="c1">; 5-byte jump to real destination</span>
<span class="nl">winfunc:</span>
        <span class="nf">jmp</span>     <span class="nv">patched</span> <span class="c1">; 2-byte relative jump (backward)</span></pre></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="patch-point-cont-d">Patch Point (cont'd)</h1><p>Looking at disassembled bytes we'd get something like:</p><p>Before:</p><pre class="highlight code objdump-nasm"><span class="x">0xcc 0xcc 0xcc 0xcc 0xcc  ; the prologue
0x89 0xff                                 ; the patch point</span></pre><p>After:</p><pre class="highlight code objdump-nasm"><span class="x">0xe9 0xf3 0xf9 0xff 0xff  ; the jmp newloc bytes
0xeb 0xf9                                 ; the short jmp</span></pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="intrinsic-functions">Intrinsic Functions</h1><ul><li>Intrinsic functions are special functions implemented directly by the compiler</li><li>Intrinsic offerings vary by compiler</li><li>They typically map directly to a small number of assembly instructions</li><li>Typical use cases are to expose functionality provided by assembly that doesn't exist in the C (or C++) standard library, such as access to SIMD operations.</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="intrinsic-functions-cont-d">Intrinsic Functions (cont'd)</h1><p>Example (Microsoft):</p><pre class="highlight code c++"><span class="n">__debugbreak</span><span class="p">();</span></pre><p>maps directly to:</p><pre class="highlight code nasm"><span class="nf">int3</span></pre></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="intrinsic-function-cont-d">Intrinsic Function (cont'd)</h1><p>Comprehensive lists for supported intrinsic functions should be provided as part of compiler documentation</p><ul><li>MSDN: <a href="https://msdn.microsoft.com/en-us/library/26td21ds.aspx">https://msdn.microsoft.com/en-us/library/26td21ds.aspx</a></li><li>GCC (4.2.4): <a href="http://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/X86-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/X86-Built_002din-Functions.html</a></li><li>Clang: <a href="http://clang.llvm.org/docs/LanguageExtensions.html#introduction">http://clang.llvm.org/docs/LanguageExtensions.html#introduction</a></li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="compiler-implemented-functions">Compiler-implemented Functions</h1><ul><li>A number of common functions may be implemented directly by the compiler inline</li><li>Methods such as strlen, memcpy, etc may fall into this category</li><li>As such, disassembly may not contain a "call" to these methods, but rather something like:</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mh">0x30</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">-</span> <span class="mh">0x0c</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">]</span>
<span class="nf">rep</span> <span class="nv">movsb</span></pre><p>in place of memcpy</p></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="lab-3">Lab 3</h1><p>Crackme</p><h1 id="lab-3a">Lab 3a</h1><p>From Assembly to C</p></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="dynamic-and-runtime-linking">Dynamic and Runtime Linking</h1></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="id2">Objectives</h1><ul><li>Understand and utilize Dynamic and Runtime loading techniques</li><li>Understand and utilize Dynamic and Runtime linking techniques</li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="what-is-dynamic-linking">What is Dynamic Linking?</h1><ul><li><dl><dt>Allows binary data to be distributed as a DLL or Shared Object file</dt><dd><ul><li>Has the same general attributes as a standard executable  (including the same file format)</li><li>Provides common library services for multiple executables without having to increase size as much as static linking</li></ul></dd></dl></li><li><dl><dt>Loaded into process space at runtime, as part of dependency resolution</dt><dd><ul><li>When target executable is run, its imports are examined by the operating system</li><li>Dynamic libraries it depends on are loaded prior to execution</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="dynamic-linking-cont-d">Dynamic Linking (cont'd)</h1><ul><li>Typically requires a static library and a header file</li><li><dl><dt>Most (read: nearly all) applications implicitly do this in one way or another</dt><dd><ul><li>C(++) Runtime code is often dynamically linked (e.g., glibc)</li><li>Ancillary, OS-provided code (e.g., kernel32) works in this fashion also</li></ul></dd></dl></li><li>Loading will fail if the required dynamic library is not present</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="runtime-linking">Runtime Linking</h1><ul><li><dl><dt>Similar to dynamic linking, but with a key difference</dt><dd><ul><li>No extra lib/header generally required</li><li>Onus is entirely on end user (e.g., the executable) to ensure that things go smoothly when loading/linking</li></ul></dd></dl></li><li>Exported functions must be located by end user</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="runtime-linking-how-to-load-a-library">Runtime Linking - How to load a library</h1><ul><li><dl><dt>Windows</dt><dd><ul><li>LoadLibrary(A|W) - Provides the interface for loading a DLL from disk into the current process</li><li>GetProcAddress  - Given an HMODULE (returned by LoadLibrary or GetModuleHandle), it will attempt to locate an exported function.</li></ul></dd></dl></li><li><dl><dt>Linux</dt><dd><ul><li>dlopen - Similar in function to LoadLibrary, it will load a shared object into the current process.</li><li>dlsym - As with GetProcAddress, it will attempt to locate an exported symbol on the provided library</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="windows-exports">Windows Exports</h1><ul><li><dl><dt>Can be exported either by name or ordinal</dt><dd><ul><li>Name - string; may (or may not) be mangled according to calling convention</li><li>Ordinal - Simply a number - Must be WORD-sized or smaller</li></ul></dd></dl></li><li>Both are really just methods of finding exported symbols</li><li>Exports can also forward to other DLLs</li></ul></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="windows-loading-a-library">Windows - Loading a Library</h1><pre class="highlight code c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Our module
</span>  <span class="n">HMODULE</span> <span class="n">hm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="c1">// Our dynamic function pointer
</span>  <span class="kt">int</span> <span class="p">(</span><span class="kr">__stdcall</span> <span class="o">*</span><span class="n">dynamicFunction</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// try to load a dll,return if we can't find it!
</span>  <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">hm</span> <span class="o">=</span> <span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">"MyLib.dll"</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to load library! %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Try to find an exported function.If it were exported by
</span>  <span class="c1">// ordinal, the 2nd param would change to: (char*)n, where
</span>  <span class="c1">// n is the ordinal number. This is a bit strange,but is
</span>  <span class="c1">// the way the API works.
</span>  <span class="n">dynamicFunction</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="kr">__stdcall</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span>
                                             <span class="s">"MyFunction@4"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dynamicFunction</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to find func! %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">dynamicFunction</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="c1">// Now we FreeLibrary (since we are done with it now)
</span>  <span class="n">FreeLibrary</span><span class="p">(</span><span class="n">hm</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="linux-loading-a-library">Linux - Loading a Library</h1><pre class="highlight code c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">hm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">myexport</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// As with loadlibrary, we pass the path to load
</span>  <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">hm</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">"./mylib.so"</span><span class="p">,</span> <span class="n">RTLD_NOW</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to find our lib! %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">errno</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// again, we get our function pointer
</span>  <span class="n">myexport</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))</span><span class="n">dlsym</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="s">"myExportedFunction"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">myexport</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to find our func! %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">errno</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// call and close!
</span>  <span class="n">result</span> <span class="o">=</span> <span class="n">myexport</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">dlclose</span><span class="p">(</span><span class="n">hm</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="python">Python</h1><ul><li>The ctypes library in Python provides an easy way to load and call exported methods</li><li>Note that the architecture of Python (32 vs 64 bit) MUST match the architecture of the DLL</li></ul><pre class="highlight code python"><span class="kn">import</span> <span class="nn">ctypes</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="s2">"mydll.dll"</span><span class="p">)</span>
<span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span> <span class="c1"># Calling the method exported at ordinal 1</span>
<span class="n">c</span><span class="p">[</span><span class="s2">"MyFunc"</span><span class="p">]()</span> <span class="c1"># calling the method "MyFunc" exported by name</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="lab-runtime-linking">Lab - Runtime Linking</h1><h1 id="labs-4-4a-4b">Labs 4, 4a, &amp; 4b</h1></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>