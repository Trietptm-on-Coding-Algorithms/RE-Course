<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Reverse Engineering</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="c-and-you">C++ And You</h1><p>How C++ Works Under the Hood</p></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand and Identify Run Time Type Information (RTTI), and its uses</li><li>Understand and Identify C++ Class Layouts in memory</li><li>Understand how Inheritance Affects C++ in-memory structure</li><li>Understand the composition of C++ class memory functions and vtables</li><li>Understand and Identify the effect of C++ Templates on generated code</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="approaching-c">Approaching C++</h1><ul><li>Compiler-generated C++ tends to be complex</li><li>Classes and inheritance create complex structures</li><li>Member functions may lack direct calls of any kind</li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="functions-in-c">Functions in C++</h1><ul><li><dl><dt>Function implementation in C++ can vary rather widely</dt><dd><ul><li>Overloading</li><li>Templates</li><li>Member Functions and Inheritance</li></ul></dd></dl></li><li>Also features differences in calling convention and implicit arguments</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="a-note-on-name-mangling">A Note on Name Mangling</h1><ul><li>Name mangling in C++ tends to be much more complex than in C</li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="classes">Classes</h1><ul><li>C++ Class structure can vary a bit based on composition</li><li>Plain Old Data (POD) types tend to be roughly analagous to C</li><li>Inherited classes and virtual methods can make class composition quite a bit more complex</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="identifying-classes">Identifying Classes</h1><ul><li>Member functions tend to make heavy use of ECX*, especially if it does not appear to have been initialized</li><li>The this pointer (passed either via ECX or as the first argument to the function) is a pointer to the top of the current class object.</li></ul><p>* NOTE: this is only true for Microsoft x86 - __thiscall on SYSTEM V and all x86_64 platforms simply pass the this pointer as an implicit first argument</p></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="constructors">Constructors</h1><ul><li>Constructors may get called in different contexts depending on how the object they back is allocated</li><li>Global objects get initialized during CRT startup (before main)</li><li>If stack allocated, call to ctor will be preceded by sub esp, &lt;sizeof(class)&gt;</li><li>If heap allocated, call to ctor will be preceded by a call to new()</li><li>In all cases, there will be a mov into ECX</li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="constructors-cont-d">Constructors (cont'd)</h1><p>Given this class:</p><pre class="highlight code c++"><span class="k">class</span> <span class="nc">TestClass</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
        <span class="kt">uint32_t</span> <span class="n">inner_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
        <span class="n">TestClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">inner_</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
        <span class="n">TestClass</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">inner_</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
        <span class="o">~</span><span class="n">TestClass</span><span class="p">()</span> <span class="p">{}</span>

        <span class="kt">uint32_t</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">inner_</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">message</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span>
                        <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="constructors-dynamic">Constructors: Dynamic</h1><pre class="highlight code c++"><span class="n">TestClass</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

<span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></pre><img src="./img/ClassDynamicAllocation.png"></img></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="constructors-stack">Constructors: Stack</h1><pre class="highlight code c++"><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">TestClass</span> <span class="n">t</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value from func: "</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="id1">Constructors: Stack</h1><img src="./img/ClassStackAllocation.png"></img></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="constructors-global">Constructors: Global</h1><pre class="highlight code c++"><span class="n">TestClass</span> <span class="nf">gTest</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value from global: "</span> <span class="o">&lt;&lt;</span> <span class="n">gTest</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre><img src="./img/ClassGlobalInitialization.png"></img></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="destructors">Destructors</h1><ul><li>Compiler ensures they get called when an object is destroyed</li><li>In a stack allocated object, the dtor will be called prior to stack frame collapse</li><li>With heap allocated objects, the dtor will be called as part of the delete process, prior to the backing memory getting freed</li><li>The dtor of global objects gets called during process cleanup, after "main" (or equivalent) returns.</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="destructors-cont-d">Destructors (cont'd)</h1><pre class="highlight code c++"><span class="n">TestClass</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="c1">// ...
</span><span class="k">delete</span> <span class="n">t</span></pre><img src="./img/ClassDynamicDtor.png"></img></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="member-functions">Member Functions</h1><pre class="highlight code c++"><span class="n">TestClass</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">();</span>
<span class="n">t</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span></pre><ul><li>Non-virtual member functions use the __thiscall calling convention (MS x86)</li><li>The "this" pointer, which points to the top of object currently being operated on, is passed via ECX (or as the implicit first argument)</li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="static-methods">Static Methods</h1><pre class="highlight code c++"><span class="n">TestClass</span><span class="o">::</span><span class="n">message</span><span class="p">(</span><span class="s">"Test"</span><span class="p">);</span></pre><ul><li>Generally, these follow somewhat more standard rules regarding calling convention</li><li>No "this" pointer is passed to static methods</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="thunks">Thunks</h1><ul><li>A small chunk of code that is called by a function, but will not return</li><li>Instead it performs some small action, and jumps to a "real" function</li><li>Target function will return to original calling code</li><li>May be used to fix up calling conventions, implement closures, or, in some cases, manage virtual function selection (among other things)</li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="class-memory-layout">Class Memory Layout</h1><ul><li>Classes containing virtual member functions get an extra hidden structure member</li><li>The vfptr (top of structure) points to the class's vtable, which contains pointers to virtual member functions.</li></ul><p>*** Important Note: The given examples are x86 based, and NOT portable to x64 without changes ***</p></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="class-layout-normalclass">Class Layout: NormalClass</h1><pre class="highlight code c++"><span class="k">class</span> <span class="nc">NormalClass</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
        <span class="kt">uint32_t</span> <span class="n">a_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
        <span class="n">NormalClass</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">a_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
        <span class="kt">uint32_t</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a_</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></pre><pre class="highlight code">NormalClass -&gt; size(4)
----------------------
0x00: | a_</pre></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="id2">Class Layout: NormalClass</h1><p>In action:</p><pre class="highlight code c++"><span class="n">NormalClass</span> <span class="nf">n</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NormalClass</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
          <span class="s">"</span><span class="se">\n</span><span class="s">First element: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></pre><p>Output:</p><pre class="highlight code bash">Size: 4
First Element: 20</pre></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="class-layout-virtualclass">Class Layout: VirtualClass</h1><pre class="highlight code c++"><span class="k">class</span> <span class="nc">VirtualClass</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
        <span class="kt">uint32_t</span> <span class="n">a_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">VirtualClass</span><span class="p">()</span> <span class="p">{}</span>
        <span class="n">VirtualClass</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">a_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a_</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></pre><pre class="highlight code">VirtualClass -&gt; size(8)
-----------------------
0x00: | (vfptr)
0x04: | a_

VirtualClass Vtable
-------------------
0x00: | &amp;VirtualClass::get</pre></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="class-layout-virtualclass2">Class Layout: VirtualClass2</h1><pre class="highlight code c++"><span class="k">class</span> <span class="nc">VirtualClass2</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
        <span class="kt">uint32_t</span> <span class="n">b_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">VirtualClass2</span><span class="p">()</span> <span class="p">{}</span>
        <span class="n">VirtualClass2</span><span class="p">()</span> <span class="o">:</span> <span class="n">b_</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">stuff</span><span class="p">()</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="n">getB</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b_</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></pre><pre class="highlight code">VirtualClass2 -&gt; size(8)
------------------------
0x00: | (vfptr)
0x04: | b_

VirtualClass2 Vtable
--------------------
0x00: | &amp;VirtualClass2::stuff
0x04: | &amp;VirtualClass2::getB</pre></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="class-layout-inheritedclass">Class Layout: InheritedClass</h1><pre class="highlight code c++"><span class="k">class</span> <span class="nc">InheritedClass</span> <span class="o">:</span>
                      <span class="k">public</span> <span class="n">VirtualClass</span><span class="p">,</span>
                      <span class="k">public</span> <span class="n">VirtualClass2</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
        <span class="kt">uint32_t</span> <span class="n">c_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
        <span class="n">InheritedClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">c_</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">VirtualClass</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">stuff</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">MessageBoxA</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="s">"Stuff"</span><span class="p">,</span> <span class="s">"Stuff"</span><span class="p">,</span> <span class="n">MB_OK</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">};</span></pre><pre class="highlight code">InheritedClass -&gt; size(20)
--------------------------
      | [Base Class VirtualClass]
0x00: | VirtualClass::(vfptr)
0x04: | VirtualClass::a_
      | [Base Class VirtualClass2]
0x08: | VirtualClass2::(vfptr)
0x0c: | VirtualClass2::b_
0x10: | c_</pre></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="class-layout-inheritedclass-cont-d">Class Layout: InheritedClass (cont'd)</h1><pre class="highlight code">InheritedClass's VirtualClass Vtable
------------------------------------
0x00: | &amp;VirtualClass::get


InheritedClass's VirtualClass2 Vtable
-------------------------------------
0x00: | &amp;InheritedClass::stuff
0x04: | &amp;VirtualClass2::getB</pre></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="inheritedclass-in-action">InheritedClass in Action</h1><pre class="highlight code c++"><span class="n">InheritedClass</span> <span class="n">h</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

<span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// VirtualClass::a_
</span><span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// VirtualClass2::b_
</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// InheritedClass::c_
</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">A: "</span>
          <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">B: "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">C: "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></pre><pre class="highlight code bash">Size: 20
A: 30
B: 20
C: 10</pre></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="inheritance-and-virtual-functions">Inheritance and Virtual Functions</h1><ul><li>Calling virtual member functions means first looking up the appropriate vtable entry</li></ul><pre class="highlight code c++"><span class="n">InheritedClass</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InheritedClass</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span></pre><p>Translates to:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span><span class="p">]</span>  <span class="c1">; vtable</span>
<span class="nf">call</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span> <span class="c1">; first method</span></pre></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="id3">Inheritance and Virtual Functions</h1><p>Similarly,</p><pre class="highlight code c++"><span class="n">InheritedClass</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InheritedClass</span><span class="p">();</span>
<span class="n">h</span><span class="o">-&gt;</span><span class="n">stuff</span><span class="p">();</span></pre><p>Translates to:</p><pre class="highlight code nasm"><span class="nf">lea</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span> <span class="c1">; Find the right vtable</span>
<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span> <span class="c1">; Fetch function ptr</span>
<span class="nf">call</span> <span class="nb">eax</span> <span class="c1">; call</span></pre></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="templates">Templates</h1><ul><li>Templated code will at least be copied once for each implementation type</li><li>Often inlined</li></ul></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="run-time-type-information">Run Time Type Information</h1><ul><li><dl><dt>Structure information generated by the compiler to support some C++ operations:</dt><dd><ul><li>Exceptions</li><li>dynamic_cast</li><li>typeid</li><li>type_info</li></ul></dd></dl></li><li>Typically only required for polymorphic classes (i.e., classes with virtual member functions)</li></ul></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="rtti-cont-d">RTTI (cont'd)</h1><ul><li>Often results in string and type information being embedded in the binary</li><li>Type descriptions tend to be compiler specific</li></ul></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="references">References</h1><ul><li>OpenRCE Article on Exception Handling and C++ Class composition by Igor Skochinsky - <a href="http://www.openrce.org/articles/full_view/21">http://www.openrce.org/articles/full_view/21</a></li><li>A bit dated now, but still somewhat relevent - C++ Under the Hood by Jan Gray - Archived at: <a href="http://www.openrce.org/articles/files/jangrayhood.pdf">http://www.openrce.org/articles/files/jangrayhood.pdf</a></li><li>The Old New Thing article about member function pointers - <a href="https://blogs.msdn.microsoft.com/oldnewthing/20040209-00/?p=40713">https://blogs.msdn.microsoft.com/oldnewthing/20040209-00/?p=40713</a></li><li>Sabanal/Yason (IBM) Presentation from Blackhat 2007 - Reversing C++ - <a href="https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf">https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf</a></li><li>The C++ Standard - <a href="https://isocpp.org/std/the-standard">https://isocpp.org/std/the-standard</a> (current);</li></ul></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="additional-topics">Additional Topics</h1><ul><li><dl><dt>Anti-debugging Techniques</dt><dd><ul><li>Many good references available</li><li>Some techniques more obscure/harder to identify than others</li></ul></dd></dl></li></ul><p>Some good compendiums on the topic:</p><p><a href="http://pferrie.host22.com/papers/antidebug.pdf">http://pferrie.host22.com/papers/antidebug.pdf</a>
<a href="http://www.openrce.org/reference_library/anti_reversing">http://www.openrce.org/reference_library/anti_reversing</a></p></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="review">Review</h1></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>